/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-exec",
factory: function (require) {
var plugin=(()=>{var V=Object.create,g=Object.defineProperty,_=Object.defineProperties,G=Object.getOwnPropertyDescriptor,z=Object.getOwnPropertyDescriptors,J=Object.getOwnPropertyNames,j=Object.getOwnPropertySymbols,Y=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty,B=Object.prototype.propertyIsEnumerable;var U=(r,e,t)=>e in r?g(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,d=(r,e)=>{for(var t in e||(e={}))S.call(e,t)&&U(r,t,e[t]);if(j)for(var t of j(e))B.call(e,t)&&U(r,t,e[t]);return r},T=(r,e)=>_(r,z(e)),K=r=>g(r,"__esModule",{value:!0});var C=(r,e)=>{for(var t in e)g(r,t,{get:e[t],enumerable:!0})},Q=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of J(e))!S.call(r,o)&&o!=="default"&&g(r,o,{get:()=>e[o],enumerable:!(t=G(e,o))||t.enumerable});return r},h=r=>Q(K(g(r!=null?V(Y(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var Z={};C(Z,{default:()=>te,execUtils:()=>y});var l=h(require("@yarnpkg/core")),O=h(require("@yarnpkg/core")),n=h(require("@yarnpkg/fslib"));var p="exec:";var y={};C(y,{loadGeneratorFile:()=>P,makeLocator:()=>x,makeSpec:()=>A,parseSpec:()=>v});var u=h(require("@yarnpkg/core")),c=h(require("@yarnpkg/fslib"));function v(r){let{params:e,selector:t}=u.structUtils.parseRange(r),o=c.npath.toPortablePath(t);return{parentLocator:e&&typeof e.locator=="string"?u.structUtils.parseLocator(e.locator):null,path:o}}function A({parentLocator:r,path:e,generatorHash:t,protocol:o}){let a=r!==null?{locator:u.structUtils.stringifyLocator(r)}:{},i=typeof t!="undefined"?{hash:t}:{};return u.structUtils.makeRange({protocol:o,source:e,selector:e,params:d(d({},i),a)})}function x(r,{parentLocator:e,path:t,generatorHash:o,protocol:a}){return u.structUtils.makeLocator(r,A({parentLocator:e,path:t,generatorHash:o,protocol:a}))}async function P(r,e,t){let{parentLocator:o,path:a}=u.structUtils.parseFileStyleRange(r,{protocol:e}),i=c.ppath.isAbsolute(a)?{packageFs:new c.CwdFS(c.PortablePath.root),prefixPath:c.PortablePath.dot,localPath:c.PortablePath.root}:await t.fetcher.fetch(o,t),s=i.localPath?{packageFs:new c.CwdFS(c.PortablePath.root),prefixPath:c.ppath.relative(c.PortablePath.root,i.localPath)}:i;i!==s&&i.releaseFs&&i.releaseFs();let f=s.packageFs,b=c.ppath.join(s.prefixPath,a);return await f.readFilePromise(b,"utf8")}var L=class{supports(e,t){return!!e.reference.startsWith(p)}getLocalPath(e,t){let{parentLocator:o,path:a}=l.structUtils.parseFileStyleRange(e.reference,{protocol:p});if(n.ppath.isAbsolute(a))return a;let i=t.fetcher.getLocalPath(o,t);return i===null?null:n.ppath.resolve(i,a)}async fetch(e,t){let o=t.checksums.get(e.locatorHash)||null,[a,i,s]=await t.cache.fetchPackageFromCache(e,o,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e),loader:()=>this.fetchFromDisk(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:a,releaseFs:i,prefixPath:l.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:s}}async fetchFromDisk(e,t){let o=await P(e.reference,p,t);return n.xfs.mktempPromise(async a=>{let i=n.ppath.join(a,"generator.js");return await n.xfs.writeFilePromise(i,o),n.xfs.mktempPromise(async s=>{if(await this.generatePackage(s,e,i,t),!n.xfs.existsSync(n.ppath.join(s,"build")))throw new Error("The script should have generated a build directory");return await l.tgzUtils.makeArchiveFromDirectory(n.ppath.join(s,"build"),{prefixPath:l.structUtils.getIdentVendorPath(e),compressionLevel:t.project.configuration.get("compressionLevel")})})})}async generatePackage(e,t,o,a){return await n.xfs.mktempPromise(async i=>{let s=await l.scriptUtils.makeScriptEnv({project:a.project,binFolder:i}),f=n.ppath.join(e,"runtime.js");return await n.xfs.mktempPromise(async b=>{let E=n.ppath.join(b,"buildfile.log"),I=null,F=n.xfs.createWriteStream(E),W=F,R=n.ppath.join(e,"generator"),D=n.ppath.join(e,"build");await n.xfs.mkdirPromise(R),await n.xfs.mkdirPromise(D);let $={tempDir:n.npath.fromPortablePath(R),buildDir:n.npath.fromPortablePath(D),locator:l.structUtils.stringifyLocator(t)};await n.xfs.writeFilePromise(f,`
          // Expose 'Module' as a global variable
          Object.defineProperty(global, 'Module', {
            get: () => require('module'),
            configurable: true,
            enumerable: false,
          });

          // Expose non-hidden built-in modules as global variables
          for (const name of Module.builtinModules.filter((name) => name !== 'module' && !name.startsWith('_'))) {
            Object.defineProperty(global, name, {
              get: () => require(name),
              configurable: true,
              enumerable: false,
            });
          }

          // Expose the 'execEnv' global variable
          Object.defineProperty(global, 'execEnv', {
            value: {
              ...${JSON.stringify($)},
            },
            enumerable: true,
          });
        `);let k=s.NODE_OPTIONS||"",q=/\s*--require\s+\S*\.pnp\.c?js\s*/g;k=k.replace(q," ").trim(),s.NODE_OPTIONS=k,F.write(`# This file contains the result of Yarn generating a package (${l.structUtils.stringifyLocator(t)})
`),F.write(`
`);let{code:M}=await l.execUtils.pipevp(process.execPath,["--require",n.npath.fromPortablePath(f),n.npath.fromPortablePath(o),l.structUtils.stringifyIdent(t)],{cwd:e,env:s,stdin:I,stdout:F,stderr:W});if(M!==0)throw n.xfs.detachTemp(b),new Error(`Package generation failed (exit code ${M}, logs can be found here: ${O.formatUtils.pretty(a.project.configuration,E,O.formatUtils.Type.PATH)})`)})})}};var N=h(require("@yarnpkg/core")),H=h(require("@yarnpkg/core")),m=h(require("@yarnpkg/core"));var X=2,w=class{supportsDescriptor(e,t){return!!e.range.startsWith(p)}supportsLocator(e,t){return!!e.reference.startsWith(p)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,o){return m.structUtils.bindDescriptor(e,{locator:m.structUtils.stringifyLocator(t)})}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,o){if(!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let{path:a,parentLocator:i}=v(e.range);if(i===null)throw new Error("Assertion failed: The descriptor should have been bound");let s=await P(m.structUtils.makeRange({protocol:p,source:a,selector:a,params:{locator:m.structUtils.stringifyLocator(i)}}),p,o.fetchOptions),f=m.hashUtils.makeHash(`${X}`,s).slice(0,6);return[x(e,{parentLocator:i,path:a,generatorHash:f,protocol:p})]}async getSatisfying(e,t,o){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let o=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),a=await m.miscUtils.releaseAfterUseAsync(async()=>await N.Manifest.find(o.prefixPath,{baseFs:o.packageFs}),o.releaseFs);return T(d({},e),{version:a.version||"0.0.0",languageName:a.languageName||t.project.configuration.get("defaultLanguageName"),linkType:H.LinkType.HARD,dependencies:a.dependencies,peerDependencies:a.peerDependencies,dependenciesMeta:a.dependenciesMeta,peerDependenciesMeta:a.peerDependenciesMeta,bin:a.bin})}};var ee={fetchers:[L],resolvers:[w]},te=ee;return Z;})();
return plugin;
}
};
